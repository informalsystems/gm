#!/usr/bin/env sh
set -eu
if [ "${DEBUG:-}" = "2" ]; then
  set -x
fi

version() {
  VERSION="v0.1.5"
  if is_json_output; then
    echo '{"status": "success", "message": "'"${VERSION}"'"}'
  else
    echo "$VERSION"
  fi
}

# Configuration Management
###

# Get the operating system in lowercase letters. Works for linux and darwin.
get_operating_system() {
  # uname is optional, we will assume linux if it's missing in some streamlined docker images.
  OP_SYS="$(uname -s || echo)"
  case "${OP_SYS}" in
    "Linux" )
      echo linux
      ;;
    "Darwin" )
      echo darwin
      ;;
    * )
      echo linux
      ;;
  esac
}

set_config_defaults() {
    OP_SYS="$(get_operating_system)"
    GLOBAL_GAIAD_BINARY="$(which gaiad || echo "https://github.com/cosmos/gaia/releases/download/v5.0.6/gaiad-v5.0.6-${OP_SYS}-amd64")"
    #GLOBAL_PORTS_START_AT is deliberately not exported because it is updated sometimes during execution
    DEFAULT_PORTS_START_AT=27000
    GLOBAL_HOME_DIR="${HOME}/.gm"
    GLOBAL_AUTO_MAINTAIN_CONFIG="true"
    GLOBAL_ADD_TO_HERMES="false"
    GLOBAL_VALIDATOR_MNEMONIC=""
    GLOBAL_WALLET_MNEMONIC=""
    GLOBAL_EXTRA_WALLETS=0
    GLOBAL_HDPATH=""
    GLOBAL_HERMES_BINARY="$(which hermes || echo "./hermes")"
    GLOBAL_HERMES_CONFIG="${HOME}/.hermes/config.toml"
    GLOBAL_HERMES_LOG_LEVEL="info"
    GLOBAL_HERMES_TELEMETRY_ENABLED="true"
    GLOBAL_HERMES_TELEMETRY_HOST="127.0.0.1"
    GLOBAL_HERMES_TELEMETRY_PORT="3001"
}

parse_config_file() {
  set_config_defaults
  find_config_file
  if [ ! -f "$CONFIG_FILE" ]; then
    write_default_config_file
  fi
  # File integrity check
  stoml -s "$CONFIG_FILE" global 1> /dev/null || exit_with_error invalid config file. Make sure all strings are quoted and the global section exits
  # Note:
  #   Shellcheck SC2155: Declare and assign separately to avoid masking return values.
  #   This is irrelevant here, because the return code is taken into account.
  # shellcheck disable=SC2155
  export GLOBAL_GAIAD_BINARY="$(eval echo "$(stoml -sq "$CONFIG_FILE" global.gaiad_binary || echo "$GLOBAL_GAIAD_BINARY")")"
  # shellcheck disable=SC2155
  export GLOBAL_HOME_DIR="$(eval echo "$(stoml -sq "$CONFIG_FILE" global.home_dir || echo "$GLOBAL_HOME_DIR")")"
  # shellcheck disable=SC2155
  export GLOBAL_AUTO_MAINTAIN_CONFIG="$(stoml -sq "$CONFIG_FILE" global.auto_maintain_config || echo "$GLOBAL_AUTO_MAINTAIN_CONFIG")"
  # shellcheck disable=SC2155
  export GLOBAL_ADD_TO_HERMES="$(stoml -sq "$CONFIG_FILE" global.add_to_hermes || echo "$GLOBAL_ADD_TO_HERMES")"
  # shellcheck disable=SC2155
  export GLOBAL_VALIDATOR_MNEMONIC="$(stoml -sq "$CONFIG_FILE" global.validator_mnemonic || echo "$GLOBAL_VALIDATOR_MNEMONIC")"
  # shellcheck disable=SC2155
  export GLOBAL_WALLET_MNEMONIC="$(stoml -sq "$CONFIG_FILE" global.wallet_mnemonic || echo "$GLOBAL_WALLET_MNEMONIC")"
  # shellcheck disable=SC2155
  export GLOBAL_EXTRA_WALLETS="$(stoml -sq "$CONFIG_FILE" global.extra_wallets || echo "$GLOBAL_EXTRA_WALLETS")"
  # shellcheck disable=SC2155
  export GLOBAL_HDPATH="$(stoml -sq "$CONFIG_FILE" global.hdpath || echo "$GLOBAL_HDPATH")"
  # shellcheck disable=SC2155
  export GLOBAL_HERMES_BINARY="$(eval echo "$(stoml -sq "$CONFIG_FILE" global.hermes.binary || echo "$GLOBAL_HERMES_BINARY")")"
  # shellcheck disable=SC2155
  export GLOBAL_HERMES_CONFIG="$(eval echo "$(stoml -sq "$CONFIG_FILE" global.hermes.config || echo "$GLOBAL_HERMES_CONFIG")")"
  # shellcheck disable=SC2155
  export GLOBAL_HERMES_LOG_LEVEL="$(stoml -sq "$CONFIG_FILE" global.hermes.log_level || echo "$GLOBAL_HERMES_LOG_LEVEL")"
  # shellcheck disable=SC2155
  export GLOBAL_HERMES_TELEMETRY_ENABLED="$(stoml -sq "$CONFIG_FILE" global.hermes.telemetry_enabled || echo "$GLOBAL_HERMES_TELEMETRY_ENABLED")"
  # shellcheck disable=SC2155
  export GLOBAL_HERMES_TELEMETRY_HOST="$(stoml -sq "$CONFIG_FILE" global.hermes.telemetry_host || echo "$GLOBAL_HERMES_TELEMETRY_HOST")"
  # shellcheck disable=SC2155
  export GLOBAL_HERMES_TELEMETRY_PORT="$(stoml -sq "$CONFIG_FILE" global.hermes.telemetry_port || echo "$GLOBAL_HERMES_TELEMETRY_PORT")"

  RAW_SECTIONS="$(load_all_sections || echo "")"
  VALIDATORS=""
  RAW_NODES=""
  ALL_HERMES_NODES=""
  for i in $RAW_SECTIONS
  do
    if [ "$i" = "global" ] || [ "$i" = "global.hermes" ]; then
      continue
    fi
    if [ "$i" = "explorer" ]; then
      warn "invalid section: 'explorer' in configuration"
      continue
    fi
    if [ -z "$(stoml "$CONFIG_FILE" "${i}.network")" ]; then
      VALIDATORS="$VALIDATORS $i"
      if get_add_to_hermes "$i"; then
        ALL_HERMES_NODES="$ALL_HERMES_NODES $i"
      fi
    else
      RAW_NODES="$RAW_NODES $i"
    fi
  done
  FULL_NODES=""
  for i in $RAW_NODES
  do
    NODE_NETWORK="$(stoml "$CONFIG_FILE" "${i}.network")"
    if ! a_in_b "${NODE_NETWORK}" "$VALIDATORS"; then
      warn "invalid full node: $i, invalid network entry: ${NODE_NETWORK}, skipping..."
      continue
    fi
    FULL_NODES="${FULL_NODES} $i"
    if get_add_to_hermes "$i"; then
      ADD="yes"
      for j in $ALL_HERMES_NODES
      do
        if a_in_b "$j" "$VALIDATORS"; then
          if [ "$NODE_NETWORK" = "$j" ]; then
            warn "$i is a node on network $NODE_NETWORK and there is already a node for that network in the hermes config, skipping..."
            ADD="no"
            break
          fi
        else
          J_NODE_NETWORK="$(get_network "$j")"
          if [ "$NODE_NETWORK" = "$J_NODE_NETWORK" ]; then
            warn "$i is a node on network $NODE_NETWORK and there is already a node for that network in the hermes config, skipping..."
            ADD="no"
            break
          fi
        fi
      done
      if [ "$ADD" = "yes" ]; then
        ALL_HERMES_NODES="$ALL_HERMES_NODES $i"
      fi
    fi
  done
  VALIDATORS="${VALIDATORS## }"
  FULL_NODES="${FULL_NODES## }"
  ALL_HERMES_NODES="${ALL_HERMES_NODES## }"
  export VALIDATORS
  export FULL_NODES
  export ALL_HERMES_NODES
  export ALL_NODES="$VALIDATORS $FULL_NODES"
  # Workaround for issue: https://github.com/spf13/viper/issues/1131
  #   Fix "stoml" so it reads empty sections too.
  for v in $VALIDATORS
  do
    # This will fill in the ports_start_at entry in all sections so empty sections have at least one entry.
    get_ports_start_at "$v" 1> /dev/null
  done
  # End of workaround
}

write_default_config_file() {
  set +e
  cat <<EOF > "$CONFIG_FILE"
[global]
gaiad_binary="$GLOBAL_GAIAD_BINARY"

[global.hermes]
binary="$GLOBAL_HERMES_BINARY"

EOF
  set -e
}

find_config_file() {
  if [ -n "${GM_TOML:-}" ] && [ -f "${GM_TOML:-}" ]; then
    # shellcheck disable=SC2155
    export CONFIG_DIR="$(dirname "${GM_TOML}")"
    export CONFIG_FILE="${GM_TOML}"
  else
    if [ -f "${SCRIPT_DIR}gm.toml" ]; then
      export CONFIG_DIR="${SCRIPT_DIR}"
    elif [ -f "${HOME}/.gm/gm.toml" ]; then
      export CONFIG_DIR="${HOME}/.gm/"
    elif [ -d "${HOME}/.gm" ]; then
      export CONFIG_DIR="${HOME}/.gm/"
    else
      export CONFIG_DIR="${SCRIPT_DIR}"
    fi
    export CONFIG_FILE="${CONFIG_DIR}gm.toml"
  fi
}

# End Configuration Management
###

install() {
  mkdir -p "${HOME}/.gm/bin"
  cp "$0" "${HOME}/.gm/bin/gm"
  chmod 755 "${HOME}/.gm/bin/gm"
  cp "${0%%gm}lib-gm" "${HOME}/.gm/bin/lib-gm"
  chmod 644 "${HOME}/.gm/bin/lib-gm"
  cp "${0%%gm}shell-support" "${HOME}/.gm/bin/shell-support"
  chmod 644 "${HOME}/.gm/bin/shell-support"
  CONFIG_FILE="${HOME}/.gm/gm.toml"
  if [ -f "$CONFIG_FILE" ]; then
    warn "Config file already exists. Please double-check the documentation to see if all necessary configuration items are set."
  else
    set_config_defaults
    write_default_config_file
  fi
  if [ -z "$(which stoml)" ]; then
    warn "missing mandatory stoml, install it from https://github.com/freshautomations/stoml/releases"
  fi
  if [ -z "$(which sconfig)" ]; then
    warn "missing mandatory sconfig, install it from https://github.com/freshautomations/sconfig/releases"
  fi
  OS="$(uname -s)"
  if [ "$OS" = "Darwin" ]; then
    if [ ! -d /usr/local/etc/bash_completion.d ]; then
      warn "run \"brew install bash-completion\" to install optional bash completion"
    fi
  else
    if [ ! -d /etc/bash_completion.d ]; then
      warn "run \"apt-get install bash-completion || yum install bash-completion\" to install optional bash completion"
    fi
  fi
  echo "Please add \"source $HOME/.gm/bin/shell-support\" to your .profile, .bash_profile or other startup script and restart your shell."
}

enforce_requirements() {
  if [ -z "$(which sconfig || echo)" ]; then
    exit_with_error "missing sconfig, install it from https://github.com/freshautomations/sconfig/releases"
  fi
  SED="$(which sed || echo)"
  if [ -z "$SED" ]; then
    exit_with_error "missing sed, please install it"
  fi
  if [ -z "$(which tr || echo)" ]; then
    exit_with_error "missing tr, please install it"
  fi
  if [ -z "$(which basename || echo)" ]; then
    exit_with_error "missing basename, please install it"
  fi
  if [ -z "$(which dirname || echo)" ]; then
    exit_with_error "missing dirname, please install it"
  fi
  STOML="$(which stoml || echo)"
  if [ -z "$STOML" ]; then
    exit_with_error "missing stoml, install it from https://github.com/freshautomations/stoml/releases"
  fi
  STOML_VERSION="$("$STOML" --version | "$SED" 's/^stoml version //')"
  MAJOR="$(echo "${STOML_VERSION}" | "$SED" "s/^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)$/\1/")"
  MINOR="$(echo "${STOML_VERSION}" | "$SED" "s/^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)$/\2/")"
  #PATCH="$(echo "${STOML_VERSION}" | "$SED" "s/^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)$/\3/")"
  if [ $((MAJOR)) -eq 0 ] && [ $((MINOR)) -lt 7 ]; then
    exit_with_error "stoml too old, install 0.7.0 or newer from https://github.com/freshautomations/stoml/releases"
  fi
  if [ -z "$(which sort || echo)" ]; then
    exit_with_error "missing sort, please install it"
  fi
  if ! test "$(echo "a\nb" | sort -Vr | sed -n '1p')" = "b"; then
    exit_with_error "missing sort -V, please install a newer version of sort"
  fi
}

is_json_output() {
  test "${OUTPUT:-}" = "json"
}

disable_when_json() {
  if is_json_output; then
      exit_with_error "not implemented"
      exit 0
  fi
}

info() {
  if ! is_json_output; then
    echo "$*" >&2
  fi
}

debug() {
  if [ -n "${DEBUG:-}" ]; then
    echo "DEBUG: $*" >&2
  fi
}

warn() {
  if ! is_json_output; then
    echo "WARNING: $*" >&2
  fi
}

warn_unknown_node() {
  if ! is_json_output; then
    if ! a_in_b "$1" "$ALL_NODES"; then
      warn "unknown node $1, skipping..."
      return 1
    fi
  fi
}

warn_unknown_hermes_node() {
  if ! a_in_b "$1" "$ALL_HERMES_NODES"; then
    warn "not a hermes node $1, skipping..."
    return 1
  fi
}

exit_with_error() {
  if is_json_output; then
    echo '{"status": "error", "message": "'"$*"'"}' >&2
  else
    echo "ERROR: $*, exiting..." >&2
    return 1
  fi
}

# Functions
###

# Is string A in space-separated list B?
a_in_b() {
  test -n "$(echo "$2" | grep '\(^\| \+\)'"${1}"'\( \+\|$\)')"
}

# Is string A in comma-separated list B?
a_in_b_comma_separated() {
  test -n "$(echo "$2" | grep '\(^\|,\) *'"${1}"' *\(,\|$\)')"
}

# Return the n-th value from a comma-separated list.
# Starts with 1.
n_from_a() {
  i=1
  N=$(($1))
  shift
  LIST="$*"
  for j in $LIST
  do
    if [ $((N-i)) -eq 0 ]; then
      echo "$j"
      return 0
    fi
    i=$((i+1))
  done
  return 1
}

# End Functions
###

# Function to work around https://github.com/spf13/viper/issues/1131
# This function can be replaced with `stoml -q "$CONFIG_FILE" .` after the issue is fixed.
load_all_sections() {
  grep '^ *\[.\+\] *$' "$CONFIG_FILE" | sed 's/^ *\[\([^]]*\)\] *$/\1/'
}

get_url_id() {
  SUMMARIZER="$(which md5sum || which shasum || which sha256sum)"
  if [ -z "${SUMMARIZER}" ]; then
    echo "${1}" | tr -d ":/?=.&"
  else
    SUMMARY="$(echo "${1}" | "${SUMMARIZER}")"
    SUMMARY="${SUMMARY%%  -}"
    echo "${SUMMARY}"
  fi
}

eval_binary() {
  RAW_BINARY="$(eval echo "${1}")"
  if [ "${RAW_BINARY##http://}" != "$RAW_BINARY" ] || [ "${RAW_BINARY##https://}" != "$RAW_BINARY" ] || [ "${RAW_BINARY##ftp://}" != "$RAW_BINARY" ]; then
    FILE_URL_PATH="$(dirname "${RAW_BINARY}")"
    FILE_URL_PATH_ID="$(get_url_id "${FILE_URL_PATH}")"
    if [ ! -d "${CONFIG_DIR}${FILE_URL_PATH_ID}" ]; then
      mkdir "${CONFIG_DIR}${FILE_URL_PATH_ID}" || exit_with_error "could not create temporary folder ${CONFIG_DIR}${FILE_URL_PATH_ID} to download binary ${RAW_BINARY}"
    fi
    FILE_NAME="$(basename "${RAW_BINARY}" | tr -d "?=&")"
    BINARY="${CONFIG_DIR}${FILE_URL_PATH_ID}/${FILE_NAME}"
    if [ -x "${BINARY}" ]; then
      echo "${BINARY}"
    else
      DOWNLOADER="$(which wget)"
      if [ -n "${DOWNLOADER}" ]; then
        debug "downloading ${RAW_BINARY} using wget..."
        # shellcheck disable=SC2086
        "${DOWNLOADER}" -q -nd ${WGET_DOWNLOAD_OPTIONS:-} "${RAW_BINARY}" -O "${BINARY}" || exit_with_error wget "${RAW_BINARY}" failed
        chmod +x "${BINARY}"
        echo "${BINARY}"
      else
        DOWNLOADER="$(which curl)"
        if [ -n "${DOWNLOADER}" ]; then
          debug "downloading ${RAW_BINARY} using curl..."
          # shellcheck disable=SC2086
          "${DOWNLOADER}" -s -f -L ${CURL_DOWNLOAD_OPTIONS:-} "${RAW_BINARY}" -o "${BINARY}" || exit_with_error curl "${RAW_BINARY}" failed
          chmod +x "${BINARY}"
          echo "${BINARY}"
        else
          exit_with_error "found URL ${RAW_BINARY} but no downloader wget or curl"
        fi
      fi
    fi
  else
    if [ -x "${RAW_BINARY}" ]; then
      echo "${RAW_BINARY}"
    else
      exit_with_error "binary \"${RAW_BINARY}\" not found or not executable, check your gm.toml config"
    fi
  fi
}

get_gaiad_binary() {
  RESULT="$(stoml -q "$CONFIG_FILE" "${1}.gaiad_binary")"
  if [ -z "$RESULT" ]; then
    eval_binary "$GLOBAL_GAIAD_BINARY"
  else
    eval_binary "$RESULT"
  fi
}

get_hermes_binary() {
  eval_binary "$GLOBAL_HERMES_BINARY"
}

get_ports_start_at() {
  RESULT="$(stoml -q "$CONFIG_FILE" "${1}.ports_start_at")"
  if [ -z "$RESULT" ]; then
    THIS_PORTS_START_AT="$(stoml -sq "$CONFIG_FILE" global.ports_start_at || echo "$DEFAULT_PORTS_START_AT")"
    sconfig "$CONFIG_FILE" -t int "global.ports_start_at=$((THIS_PORTS_START_AT+10))" 1> /dev/null
    sconfig "$CONFIG_FILE" -t int "${1}.ports_start_at=$THIS_PORTS_START_AT" 1> /dev/null
    echo "$THIS_PORTS_START_AT"
  else
    echo "$RESULT"
  fi
}

get_rpc_port() {
  get_ports_start_at "$1"
}

get_app_port() {
  echo "$(($(get_ports_start_at "$1")+1))"
}

get_grpc_port() {
  echo "$(($(get_ports_start_at "$1")+2))"
}

get_p2p_port() {
  echo "$(($(get_ports_start_at "$1")+3))"
}

get_pprof_port() {
  echo "$(($(get_ports_start_at "$1")+4))"
}

get_grpcw_port() {
  echo "$(($(get_ports_start_at "$1")+5))"
}

get_home_dir() {
  RESULT="$(stoml -q "$CONFIG_FILE" "${1}.home_dir")"
  if [ -z "$RESULT" ]; then
    echo "$GLOBAL_HOME_DIR/$1"
  else
    eval echo "$RESULT"
  fi
}

get_auto_maintain_config() {
  RESULT="$(stoml -q "$CONFIG_FILE" "${1}.auto_maintain_config")"
  if [ -z "$RESULT" ]; then
    test "$GLOBAL_AUTO_MAINTAIN_CONFIG" = "true"
  else
    test "$RESULT" = "true"
  fi
}

get_network() {
  RESULT="$(stoml -q "$CONFIG_FILE" "${1}.network")"
  if [ -z "$RESULT" ]; then
    RESULT="$1"
  else
    if ! a_in_b "$RESULT" "$VALIDATORS"; then
      return 1
    fi
  fi
  echo "$RESULT"
}

# Note: this depends on one-validator nodes.
# We might want to change it to `stoml -q "${HOME_DIR}/config/genesis.json" "chain_id"` later.
get_chain_id() {
  if a_in_b "$1" "$VALIDATORS"; then
    echo "$1"
  else
    get_network "$1"
  fi
}

# Returns empty string if --long is not supported
get_sdk_version() {
  GAIAD_BINARY="$(get_gaiad_binary "$1")"
  RESULT="$("$GAIAD_BINARY" version --long 2>&1 | sed -n '/cosmos_sdk_version/ s/cosmos_sdk_version: v\(.*\)$/\1/p')"
  echo "$RESULT"
}

get_genesis_cmd_prefix() {
    GENESIS_BREAKING_VERSION="0.47.0"
    SDK_VERSION="$(get_sdk_version "$1")"
    RESULT=""
    if [ -z "$SDK_VERSION" ]; then
      # Handle the sdk version error here, happens when --long is not supported
      GAIAD_BINARY="$(get_gaiad_binary "$1")"
      RESULT="$($GAIAD_BINARY | grep -q 'gentx' || echo "genesis")"
    else
      HIGHER_VERSION=$(echo "${GENESIS_BREAKING_VERSION}\n${SDK_VERSION}" | sort -Vr | sed -n '1p')
      if [ "$HIGHER_VERSION" = "$SDK_VERSION" ]; then
        # Perform actions for the >= 0.47.0 case here
        RESULT="genesis"
      fi
    fi
    echo "$RESULT"
}

get_add_to_hermes() {
  RESULT="$(stoml -q "$CONFIG_FILE" "${1}.add_to_hermes")"
  if [ -z "$RESULT" ]; then
    test "$GLOBAL_ADD_TO_HERMES" = "true"
  else
    test "$RESULT" = "true"
  fi
}

get_node_id() {
  GAIAD_BINARY="$(get_gaiad_binary "$1")"
  HOME_DIR="$(get_home_dir "$1")"
  if [ ! -f "${HOME_DIR}/config/node_key.json" ]; then
    warn "Invalid configuration: no node key found for $1"
    echo "DEADBEEFDEADBEEF"
  else
    "$GAIAD_BINARY" tendermint show-node-id --home "$HOME_DIR"
  fi
}

get_validator_mnemonic() {
  RESULT="$(stoml -q "$CONFIG_FILE" "${1}.validator_mnemonic")"
  if [ -z "$RESULT" ]; then
    echo "$GLOBAL_VALIDATOR_MNEMONIC"
  else
    echo "$RESULT"
  fi
}

get_wallet_mnemonic() {
  RESULT="$(stoml -q "$CONFIG_FILE" "${1}.wallet_mnemonic")"
  if [ -z "$RESULT" ]; then
    echo "$GLOBAL_WALLET_MNEMONIC"
  else
    echo "$RESULT"
  fi
}

get_extra_wallets() {
  RESULT="$(stoml -q "$CONFIG_FILE" "${1}.extra_wallets")"
  if [ -z "$RESULT" ]; then
    echo "$GLOBAL_EXTRA_WALLETS"
  else
    echo "$RESULT"
  fi
}

get_hdpath() {
  RESULT="$(stoml -q "$CONFIG_FILE" "${1}.hdpath")"
  if [ -z "$RESULT" ]; then
    echo "$GLOBAL_HDPATH"
  else
    echo "$RESULT"
  fi
}

get_staking_denom() {
  NETWORK="$(get_chain_id "$1")"
  NETWORK_HOME_DIR="$(get_home_dir "$NETWORK")"
  stoml "${NETWORK_HOME_DIR}/config/genesis.json" app_state.staking.params.bond_denom
}

get_wallet_account_prefix() {
  NETWORK="$(get_chain_id "$1")"
  NETWORK_HOME_DIR="$(get_home_dir "$NETWORK")"
  WALLET_ADDRESS="$(stoml "${NETWORK_HOME_DIR}/wallet_seed.json" address)"
  IFS=1 read -r account_prefix _ <<EOF
$WALLET_ADDRESS
EOF
  echo "$account_prefix"
}

# get_consensus_key <node>
get_consensus_key() {
  GAIAD_BINARY="$(get_gaiad_binary "$1")"
  HOME_DIR="$(get_home_dir "$1")"
  "${GAIAD_BINARY}" tendermint show-validator --home "${HOME_DIR}"
}

create() {
  info "Creating $1 config..."
  GAIAD_BINARY="$(get_gaiad_binary "$1")"
  HOME_DIR="$(get_home_dir "$1")"
  NETWORK="$(get_chain_id "$1")"
  EXEC_RESULT="$("$GAIAD_BINARY" init "$1" --chain-id "$NETWORK" --home "$HOME_DIR" 2>&1)"
  echo "$EXEC_RESULT" > "${HOME_DIR}/init.json"
  if [ "$(stoml "${HOME_DIR}/init.json" moniker)" != "$1" ]; then
    warn "could not create config for ${1}: \"$EXEC_RESULT\", skipping..."
    return 1
  fi
  if a_in_b "$1" "$VALIDATORS"; then
    HDPATH="$(get_hdpath "$1")"
    # Create validator key
    VALIDATOR_MNEMONIC="$(get_validator_mnemonic "$1")"
    if [ -z "$VALIDATOR_MNEMONIC" ] && [ -z "$HDPATH" ]; then
      "$GAIAD_BINARY" keys add "validator" --keyring-backend test --keyring-dir "${HOME_DIR}" --output json 1> "${HOME_DIR}/validator_seed.json" 2>&1
    elif [ -z "$VALIDATOR_MNEMONIC" ] && [ -n "$HDPATH" ]; then
      "$GAIAD_BINARY" keys add "validator" --hd-path "$HDPATH" --keyring-backend test --keyring-dir "${HOME_DIR}" --output json 1> "${HOME_DIR}/validator_seed.json" 2>&1
    elif [ -n "$VALIDATOR_MNEMONIC" ] && [ -z "$HDPATH" ]; then
      echo "$VALIDATOR_MNEMONIC" | "$GAIAD_BINARY" keys add "validator" --recover --keyring-backend test --keyring-dir "${HOME_DIR}" --output json 1> "${HOME_DIR}/validator_seed.json" 2>&1
      sconfig "${HOME_DIR}/validator_seed.json" -t string "mnemonic=${VALIDATOR_MNEMONIC}" 1> /dev/null
    elif [ -n "$VALIDATOR_MNEMONIC" ] && [ -n "$HDPATH" ]; then
      echo "$VALIDATOR_MNEMONIC" | "$GAIAD_BINARY" keys add "validator" --hd-path "$HDPATH" --recover --keyring-backend test --keyring-dir "${HOME_DIR}" --output json 1> "${HOME_DIR}/validator_seed.json" 2>&1
      sconfig "${HOME_DIR}/validator_seed.json" -t string "mnemonic=${VALIDATOR_MNEMONIC}" 1> /dev/null
    fi
    # Create wallet key
    WALLET_MNEMONIC="$(get_wallet_mnemonic "$1")"
    if [ -z "$WALLET_MNEMONIC" ] && [ -z "$HDPATH" ]; then
      "$GAIAD_BINARY" keys add "wallet" --keyring-backend test --keyring-dir "${HOME_DIR}" --output json 1> "${HOME_DIR}/wallet_seed.json" 2>&1
    elif [ -z "$WALLET_MNEMONIC" ] && [ -n "$HDPATH" ]; then
      "$GAIAD_BINARY" keys add "wallet" --hd-path "$HDPATH" --keyring-backend test --keyring-dir "${HOME_DIR}" --output json 1> "${HOME_DIR}/wallet_seed.json" 2>&1
    elif [ -n "$WALLET_MNEMONIC" ] && [ -z "$HDPATH" ]; then
      echo "$WALLET_MNEMONIC" | "$GAIAD_BINARY" keys add "wallet" --recover --keyring-backend test --keyring-dir "${HOME_DIR}" --output json 1> "${HOME_DIR}/wallet_seed.json" 2>&1
      sconfig "${HOME_DIR}/wallet_seed.json" -t string "mnemonic=${WALLET_MNEMONIC}" 1> /dev/null
    elif [ -n "$WALLET_MNEMONIC" ] && [ -n "$HDPATH" ]; then
      echo "$WALLET_MNEMONIC" | "$GAIAD_BINARY" keys add "wallet" --hd-path "$HDPATH" --recover --keyring-backend test --keyring-dir "${HOME_DIR}" --output json 1> "${HOME_DIR}/wallet_seed.json" 2>&1
      sconfig "${HOME_DIR}/wallet_seed.json" -t string "mnemonic=${WALLET_MNEMONIC}" 1> /dev/null
    fi
    # Create extra wallets
    EXTRA_WALLETS_COUNTER="$(get_extra_wallets "$1")"
    while [ "$EXTRA_WALLETS_COUNTER" -gt 0 ];
    do
      if [ -z "$HDPATH" ]; then
        "$GAIAD_BINARY" keys add "wallet${EXTRA_WALLETS_COUNTER}" --keyring-backend test --keyring-dir "${HOME_DIR}" --output json 1> "${HOME_DIR}/wallet${EXTRA_WALLETS_COUNTER}_seed.json" 2>&1
      else #if [ -n "$HDPATH" ]; then
        "$GAIAD_BINARY" keys add "wallet${EXTRA_WALLETS_COUNTER}" --hd-path "$HDPATH" --keyring-backend test --keyring-dir "${HOME_DIR}" --output json 1> "${HOME_DIR}/wallet_seed${EXTRA_WALLETS_COUNTER}.json" 2>&1
      fi
      EXTRA_WALLETS_COUNTER="$((EXTRA_WALLETS_COUNTER - 1))"
    done
    # Add accounts to genesis
    GENESIS_CMD_PREFIX=$(get_genesis_cmd_prefix "$1")
    DENOM="$(get_staking_denom "$1")"
    # shellcheck disable=SC2086
    "$GAIAD_BINARY" $GENESIS_CMD_PREFIX add-genesis-account validator "100000000${DENOM},100000000samoleans" --keyring-backend test --home "${HOME_DIR}"
    # shellcheck disable=SC2086
    "$GAIAD_BINARY" $GENESIS_CMD_PREFIX add-genesis-account wallet "100000000${DENOM},100000000samoleans" --keyring-backend test --home "${HOME_DIR}"
    EXTRA_WALLETS_COUNTER="$(get_extra_wallets "$1")"
    while [ "$EXTRA_WALLETS_COUNTER" -gt 0 ];
    do
      # shellcheck disable=SC2086
      "$GAIAD_BINARY" $GENESIS_CMD_PREFIX add-genesis-account "wallet${EXTRA_WALLETS_COUNTER}" "100000000${DENOM},100000000samoleans" --keyring-backend test --home "${HOME_DIR}"
      EXTRA_WALLETS_COUNTER="$((EXTRA_WALLETS_COUNTER - 1))"
    done
    # Create gentx
    # shellcheck disable=SC2086
    "$GAIAD_BINARY" $GENESIS_CMD_PREFIX gentx validator "1000000${DENOM}" --keyring-backend test --keyring-dir "${HOME_DIR}" --home "${HOME_DIR}" --chain-id "$1" 2> /dev/null
    # Collect gentxs
    # shellcheck disable=SC2086
    "$GAIAD_BINARY" $GENESIS_CMD_PREFIX collect-gentxs --home "${HOME_DIR}" 2> /dev/null
    # Validate genesis
    # shellcheck disable=SC2086
    "$GAIAD_BINARY" $GENESIS_CMD_PREFIX validate-genesis --home "${HOME_DIR}" > /dev/null
  else
    NETWORK_HOME_DIR="$(get_home_dir "$NETWORK")"
    if [ -f "$NETWORK_HOME_DIR/config/genesis.json" ]; then
      cp "$NETWORK_HOME_DIR/config/genesis.json" "$HOME_DIR/config/genesis.json"
    else
      warn "${NETWORK} does not have a valid genesis.json yet"
      rm -f "${HOME_DIR}/config/genesis.json"
    fi
  fi
  configure "$1"
  sconfig "$HOME_DIR/config/config.toml" p2p.addr_book_strict=false 1> /dev/null
  sconfig "$HOME_DIR/config/config.toml" p2p.allow_duplicate_ip=true 1> /dev/null
}

configure() {
  HOME_DIR="$(get_home_dir "$1")"
  CHAIN_ID="$(get_chain_id "$1")"
  P2P="$(get_p2p_port "$1")"
  RPC="$(get_rpc_port "$1")"
  APP="$(get_app_port "$1")"
  GRPC="$(get_grpc_port "$1")"
  PPROF="$(get_pprof_port "$1")"
  GRPCW="$(get_grpcw_port "$1")"
  sconfig "$HOME_DIR/config/config.toml" "p2p.laddr=tcp://0.0.0.0:${P2P}" 1> /dev/null
  sconfig "$HOME_DIR/config/config.toml" "rpc.laddr=tcp://0.0.0.0:${RPC}" 1> /dev/null
  sconfig "$HOME_DIR/config/config.toml" "rpc.pprof_laddr=0.0.0.0:${PPROF}" 1> /dev/null
  sconfig "$HOME_DIR/config/app.toml" "api.address=tcp://0.0.0.0:${APP}" 1> /dev/null
  sconfig "$HOME_DIR/config/app.toml" "api.enable=true" 1> /dev/null
  sconfig "$HOME_DIR/config/app.toml" "api.swagger=true" 1> /dev/null
  sconfig "$HOME_DIR/config/app.toml" "grpc.address=0.0.0.0:${GRPC}" 1> /dev/null
  sconfig "$HOME_DIR/config/app.toml" "grpc-web.address=0.0.0.0:${GRPCW}" 1> /dev/null
  sconfig "$HOME_DIR/config/client.toml" "keyring-backend=test" 1> /dev/null
  sconfig "$HOME_DIR/config/client.toml" "node=tcp://127.0.0.1:${RPC}" 1> /dev/null
  sconfig "$HOME_DIR/config/client.toml" "chain-id=${CHAIN_ID}" 1> /dev/null
  if ! a_in_b "$i" "$VALIDATORS"; then
    NETWORK="$(get_network "$1")"
    NETWORK_HOME_DIR="$(get_home_dir "$NETWORK")"
    if [ ! -f "$NETWORK_HOME_DIR/config/genesis.json" ]; then
      warn "${NETWORK} does not have a genesis.json. Start ${NETWORK} first."
      return 1
    fi
    cp "$NETWORK_HOME_DIR/config/genesis.json" "$HOME_DIR/config/genesis.json"
    NETWORK_NODE="$(get_node_id "$NETWORK")@localhost:$(get_p2p_port "$NETWORK")"
    sconfig "$HOME_DIR/config/config.toml" "p2p.persistent_peers=$NETWORK_NODE" 1> /dev/null
    if get_auto_maintain_config "$NETWORK"; then
      EXISTING_PEERS="$(stoml -q "$NETWORK_HOME_DIR/config/config.toml" "p2p.unconditional_peer_ids")"
      NODE_ID="$(get_node_id "$1")"
      if ! a_in_b_comma_separated "$NODE_ID" "$EXISTING_PEERS"; then
        if [ -z "$EXISTING_PEERS" ]; then
          EXISTING_PEERS="$NODE_ID"
        else
          EXISTING_PEERS="$EXISTING_PEERS,$NODE_ID"
        fi
        sconfig "$NETWORK_HOME_DIR/config/config.toml" "p2p.unconditional_peer_ids=$EXISTING_PEERS" 1> /dev/null
      fi
    fi
  fi
}

is_running() {
  HOME_DIR="$(get_home_dir "$1")"
  GAIAD_PID_FILE="${HOME_DIR}/pid"
  if [ -f "$GAIAD_PID_FILE" ]; then
    GAIAD_PID="$(cat "$GAIAD_PID_FILE")"
    if [ -n "$GAIAD_PID" ]; then
      test "$(ps -p "$GAIAD_PID" -o pid | wc -l)" -eq 2
    else
      return 1
    fi
  else
    return 1
  fi
}

start() {
  if is_running "$1"; then
    warn "$1 is already running, skipping"
  else
    [ -z ${GENESIS_CMD_PREFIX+x} ] && GENESIS_CMD_PREFIX=$(get_genesis_cmd_prefix "$1")
    GAIAD_BINARY="$(get_gaiad_binary "$1")"
    HOME_DIR="$(get_home_dir "$1")"
    GAIAD_LOG="${HOME_DIR}/log"
    # shellcheck disable=SC2086
    VALIDATION="$("$GAIAD_BINARY" $GENESIS_CMD_PREFIX validate-genesis --home "$HOME_DIR" > "$GAIAD_LOG" 2>&1 || echo "ERR")"
    if [ "$VALIDATION" = "ERR" ]; then
      warn "validate-genesis could not complete for ${1}"
    fi
    nohup "$GAIAD_BINARY" start --home "$HOME_DIR" > "$GAIAD_LOG" 2>&1 &
    GAIAD_PID=$!
    echo "$GAIAD_PID" > "$HOME_DIR/pid"
    info "$i started, PID: $GAIAD_PID, LOG: $GAIAD_LOG"
    sleep 1
    if ! is_running "$1"; then
      warn "$1 failed. Check the logs with \`gm log $1\`."
    fi
  fi
}

stop() {
  if is_running "$1"; then
    HOME_DIR="$(get_home_dir "$1")"
    GAIAD_PID="$(cat "${HOME_DIR}/pid")"
    info "Stopping $1 with PID $GAIAD_PID..."
    kill -TERM "$GAIAD_PID" 2> /dev/null && rm -f "$HOME_DIR/pid"
    RESULT="$?"
    if [ "$RESULT" != "0" ]; then
        warn "SIGTERM failed on PID ${GAIAD_PID} for $1. Trying KILL..."
        kill -KILL "$GAIAD_PID" && rm -f "$HOME_DIR/pid"
        RESULT="$?"
        if [ "$RESULT" != "0" ]; then
          warn "SIGKILL failed on PID ${GAIAD_PID} for $1. Giving up..."
        fi
    fi
  else
    HOME_DIR="$(get_home_dir "$1")"
    if [ -f "${HOME_DIR}/pid" ]; then
      GAIAD_PID="$(cat "${HOME_DIR}/pid")"
      if [ -n "$GAIAD_PID" ]; then
        warn "no process with PID $GAIAD_PID found for $1. Removing stale data."
      else
        warn "no process ID found for $1. Removing stale data."
      fi
      rm -f "$HOME_DIR/pid"
    fi
  fi
}

print_header_line() {
  if is_json_output; then
    echo "{"
    echo '  "status": "success",'
    echo '  "message": ['
    JSON_COMMA=0
  else
    echo "NODE               PID    RPC   APP  GRPC  HOME_DIR"
  fi
}

print_footer_line() {
  if is_json_output; then
    echo "  ]"
    echo "}"
  fi
}

print_status_line() {
  if is_json_output; then
    HOME_DIR="$(get_home_dir "$1")"
    GAIAD_PID_FILE="${HOME_DIR}/pid"
    GAIAD_PID=""
    if [ -f "$GAIAD_PID_FILE" ]; then
      GAIAD_PID="$(cat "$GAIAD_PID_FILE")"
    fi
    if [ "$JSON_COMMA" = "0" ]; then
      JSON_COMMA=1
    else
      echo "    ,"
    fi
    CHAIN_ID="$1"
    if [ "${2:-}" = " " ]; then
      CHAIN_ID="$(get_network "$1")"
    fi
    if [ "${GAIAD_PID}" = "" ]; then
      cat << EOF
    {
      "name": "$1",
      "chain-id": "${CHAIN_ID}",
      "config-dir": "${HOME_DIR}"
    }
EOF
    else
      P2P="$(get_p2p_port "$1")"
      RPC="$(get_rpc_port "$1")"
      APP="$(get_app_port "$1")"
      GRPC="$(get_grpc_port "$1")"
      PPROF="$(get_pprof_port "$1")"
      GRPCW="$(get_grpcw_port "$1")"
      cat << EOF
    {
      "name": "$1",
      "chain-id": "${CHAIN_ID}",
      "pid": ${GAIAD_PID},
      "config-dir": "${HOME_DIR}",
      "ports": {
        "rpc": ${RPC},
        "app": ${APP},
        "grpc": ${GRPC},
        "p2p": ${P2P},
        "pprof": ${PPROF},
        "grpc-web": ${GRPC}
      }
    }
EOF
    fi
  else
    NAME="${2:-}$1"
    NAME_LENGTH="${#NAME}"
    NAME_PAD=""
    if [ "$NAME_LENGTH" -lt 15 ]; then
      for _ in $(seq "$NAME_LENGTH" 15);
      do
        NAME_PAD="$NAME_PAD "
      done
    fi
    HOME_DIR="$(get_home_dir "$1")"
    HOME_DIR_PRINTED=" $HOME_DIR "
    if [ ! -d "$HOME_DIR" ]; then
      HOME_DIR_PRINTED="(${HOME_DIR})"
    fi
    GAIAD_PID_FILE="${HOME_DIR}/pid"
    if [ -f "$GAIAD_PID_FILE" ]; then
      GAIAD_PID="$(cat "$GAIAD_PID_FILE")"
      if [ -z "$GAIAD_PID" ]; then
        GAIAD_PID=" N/A "
      fi
      if [ "$(ps -p "$GAIAD_PID" -o pid | wc -l)" -eq 2 ]; then
        echo "${NAME}${NAME_PAD} $GAIAD_PID  $(get_rpc_port "$1") $(get_app_port "$1") $(get_grpc_port "$1") $HOME_DIR_PRINTED"
      else
        echo "${NAME}${NAME_PAD}($GAIAD_PID)     -     -     - $HOME_DIR_PRINTED"
      fi
    else
       echo "${NAME}${NAME_PAD}     -      -     -     - $HOME_DIR_PRINTED"
    fi
  fi
}

status() {
  print_header_line
  for i in $VALIDATORS
  do
    print_status_line "$i"
    for j in $FULL_NODES
    do
      NETWORK="$(get_network "$j")"
      if [ "$i" = "$NETWORK" ]; then
        print_status_line "$j" " "
      else
        continue
      fi
    done
  done
  print_footer_line
}

ports() {
  P2P="$(get_p2p_port "$1")"
  RPC="$(get_rpc_port "$1")"
  APP="$(get_app_port "$1")"
  GRPC="$(get_grpc_port "$1")"
  PPROF="$(get_pprof_port "$1")"
  GRPCW="$(get_grpcw_port "$1")"
  echo "${1} RPC  : http://localhost:${RPC}"
  echo "${1} APP  : http://localhost:${APP}"
  echo "${1} GRPC : http://localhost:${GRPC}"
  echo "${1} P2P  : http://localhost:${P2P}"
  echo "${1} PPROF: http://localhost:${PPROF}"
  echo "${1} GRPCW: http://localhost:${GRPCW}"
}

list_keys() {
  HOME_DIR="$(get_home_dir "$1")"
  if [ ! -d "$HOME_DIR" ]; then
    warn "No configuration at ${HOME_DIR}. Skipping..."
    return 0
  fi
  GAIAD_BINARY="$(get_gaiad_binary "$1")"
  echo "\"$GAIAD_BINARY\" keys list --keyring-backend test --keyring-dir \"$HOME_DIR\""
  KEY_NAME=""
  "$GAIAD_BINARY" keys list --keyring-backend test --keyring-dir "$HOME_DIR" | while read -r line
  do
    NAME="${line##'- name: '}"
    TYPE="${line##'type: '}"
    MNEMONIC="${line##'mnemonic:'}"
    THRESHOLD="${line##'threshold: '}"
    PUBKEYS="${line##'pubkeys: '}"
    if [ "$NAME" != "$line" ]; then
      KEY_NAME="$NAME"
      echo
      echo "$line"
    elif [ "$TYPE" != "$line" ]; then
      if [ "$line" != "type: local" ]; then
        echo "$line"
      fi
    elif [ "$MNEMONIC" != "$line" ]; then
      if a_in_b "${KEY_NAME%%v0}" "$VALIDATORS"; then
        echo "mnemonic: \"$(stoml "${HOME_DIR}/key_seed.json" secret)\""
      elif a_in_b "${KEY_NAME%%n0}" "$FULL_NODES"; then
        echo "mnemonic: \"$(stoml "${HOME_DIR}/key_seed.json" secret)\""
      elif [ -f "${HOME_DIR}/${KEY_NAME}_seed.json" ]; then
        echo "mnemonic: \"$(stoml "${HOME_DIR}/${KEY_NAME}_seed.json" mnemonic)\""
      else
        echo "mnemonic: \"\""
      fi
    elif [ "$THRESHOLD" != "$line" ]; then
      if [ "$line" != "threshold: 0" ]; then
        echo "$line"
      fi
    elif [ "$PUBKEYS" != "$line" ]; then
      if [ "$line" != "pubkeys: []" ]; then
        echo "$line"
      fi
    else
      echo "$line"
    fi
  done
}

hermes_config() {
  HERMES_DIR="$(dirname "$GLOBAL_HERMES_CONFIG")"
  if [ ! -d "$HERMES_DIR" ]; then
    mkdir -p "$HERMES_DIR"
  fi
  cat <<EOF > "$GLOBAL_HERMES_CONFIG"
[global]
log_level = '${GLOBAL_HERMES_LOG_LEVEL}'

[mode]

[mode.clients]
enabled = true
refresh = true
misbehaviour = true

[mode.connections]
enabled = true

[mode.channels]
enabled = true

[mode.packets]
enabled = true
clear_interval = 100
clear_on_start = true
tx_confirmation = true

[telemetry]
enabled = ${GLOBAL_HERMES_TELEMETRY_ENABLED}
host = '${GLOBAL_HERMES_TELEMETRY_HOST}'
port = ${GLOBAL_HERMES_TELEMETRY_PORT}

EOF
  for i in $ALL_NODES
  do
    if ! get_add_to_hermes "$i"; then
      continue
    fi
    RPC="$(get_rpc_port "$i")"
    GRPC="$(get_grpc_port "$i")"
    ID="$(get_chain_id "$i")"
    ACCOUNT_PREFIX="$(get_wallet_account_prefix "$i")"
    DENOM="$(get_staking_denom "$i")"
    cat <<EOF >> "$GLOBAL_HERMES_CONFIG"
[[chains]]
id = '${ID}'
rpc_addr = 'http://localhost:${RPC}'
grpc_addr = 'http://localhost:${GRPC}'
websocket_addr = 'ws://localhost:${RPC}/websocket'
rpc_timeout = '15s'
account_prefix = '${ACCOUNT_PREFIX}'
key_name = 'wallet'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = '${DENOM}' }
gas_multiplier = 1.1
default_gas = 1000000
max_gas = 10000000
max_msg_num = 30
max_tx_size = 2097152
clock_drift = '5s'
max_block_time = '30s'
trusting_period = '14days'
trust_threshold = { numerator = '2', denominator = '3' }

# [chains.packet_filter]
# policy = 'allow'
# list = [
#   ['ica*', '*'],
#   ['transfer', 'channel-0'],
# ]

EOF
    done
}

hermes_keys() {
  ID="$(get_chain_id "$1")"
  NETWORK_HOME_DIR="$(get_home_dir "$ID")"
  HERMES_BINARY="$(get_hermes_binary)"
  HDPATH="$(get_hdpath "$1")"
  if [ -z "$GLOBAL_HERMES_CONFIG" ] && [ -z "$HDPATH" ]; then
      "$HERMES_BINARY" keys add --chain "$ID" --key-file "${NETWORK_HOME_DIR}/wallet_seed.json" --overwrite
  elif [ -n "$GLOBAL_HERMES_CONFIG" ] && [ -z "$HDPATH" ]; then
      "$HERMES_BINARY" --config "$GLOBAL_HERMES_CONFIG" keys add --chain "$ID" --key-file "${NETWORK_HOME_DIR}/wallet_seed.json" --overwrite
  elif [ -z "$GLOBAL_HERMES_CONFIG" ] && [ -n "$HDPATH" ]; then
      "$HERMES_BINARY" keys add --chain "$ID" --hd-path "$HDPATH" --key-file "${NETWORK_HOME_DIR}/wallet_seed.json" --overwrite
  elif [ -n "$GLOBAL_HERMES_CONFIG" ] && [ -n "$HDPATH" ]; then
      "$HERMES_BINARY" --config "$GLOBAL_HERMES_CONFIG" keys add --chain "$ID" --hd-path "$HDPATH" --key-file "${NETWORK_HOME_DIR}/wallet_seed.json" --overwrite
  fi
  EXTRA_WALLETS_COUNTER="$(get_extra_wallets "$1")"
  while [ "$EXTRA_WALLETS_COUNTER" -gt 0 ];
  do
    if [ -z "$GLOBAL_HERMES_CONFIG" ] && [ -z "$HDPATH" ]; then
        "$HERMES_BINARY" keys add --chain "$ID" --key-name "wallet${EXTRA_WALLETS_COUNTER}" --key-file "${NETWORK_HOME_DIR}/wallet${EXTRA_WALLETS_COUNTER}_seed.json" --overwrite
    elif [ -n "$GLOBAL_HERMES_CONFIG" ] && [ -z "$HDPATH" ]; then
        "$HERMES_BINARY" --config "$GLOBAL_HERMES_CONFIG" keys add --chain "$ID" --key-name "wallet${EXTRA_WALLETS_COUNTER}" --key-file "${NETWORK_HOME_DIR}/wallet${EXTRA_WALLETS_COUNTER}_seed.json" --overwrite
    elif [ -z "$GLOBAL_HERMES_CONFIG" ] && [ -n "$HDPATH" ]; then
        "$HERMES_BINARY" keys add --chain "$ID" --hd-path "$HDPATH" --key-name "wallet${EXTRA_WALLETS_COUNTER}" --key-file "${NETWORK_HOME_DIR}/wallet${EXTRA_WALLETS_COUNTER}_seed.json" --overwrite
    elif [ -n "$GLOBAL_HERMES_CONFIG" ] && [ -n "$HDPATH" ]; then
        "$HERMES_BINARY" --config "$GLOBAL_HERMES_CONFIG" keys add --chain "$ID" --hd-path "$HDPATH" --key-name "wallet${EXTRA_WALLETS_COUNTER}" --key-file "${NETWORK_HOME_DIR}/wallet${EXTRA_WALLETS_COUNTER}_seed.json" --overwrite
    fi
    EXTRA_WALLETS_COUNTER="$((EXTRA_WALLETS_COUNTER - 1))"
  done
}

hermes_cc() {
  CHAINS=""
  for i in $ALL_HERMES_NODES
  do
    if ! a_in_b "$i" "$CHAINS"; then
      ID="$(get_chain_id "$i")"
      CHAINS="$CHAINS $ID"
    fi
  done
  CHAINS="${CHAINS## }"
  N="$(($(echo "$CHAINS" | wc -w)))"
  HERMES_BINARY="$(get_hermes_binary)"
  for i in $(seq 1 $((N-1)))
  do
    for j in $(seq $((i+1)) $N)
    do
      echo "\"${HERMES_BINARY}\" create channel --a-chain $(n_from_a "$i" "$CHAINS") --b-chain $(n_from_a "$j" "$CHAINS") --a-port transfer --b-port transfer --new-client-connection --yes"
    done
  done
}

reset() {
  WAS_RUNNING="$(is_running "$1" || echo "no")"
  if [ -z "$WAS_RUNNING" ]; then
    if a_in_b "$1" "$VALIDATORS"; then
      warn "After reset all full nodes will need to be reset too."
    fi
    stop "$1"
  fi
  GAIAD_BINARY="$(get_gaiad_binary "$1")"
  HOME_DIR="$(get_home_dir "$1")"
  info "Resetting $1..."
  if [ ! -d "$HOME_DIR" ]; then
    warn "No configuration at ${HOME_DIR}. Skipping..."
    return 0
  fi
  # `unsafe-reset-all` was moved to `gaiad tendermint` sub-command
  TM="$($GAIAD_BINARY | grep -q 'unsafe' || echo "tendermint")"
  if is_json_output; then
    "$GAIAD_BINARY" "$TM" unsafe-reset-all --home "$HOME_DIR" 1> /dev/null 2> /dev/null
  else
    "$GAIAD_BINARY" "$TM" unsafe-reset-all --home "$HOME_DIR"
  fi
  if [ -z "$WAS_RUNNING" ]; then
    start "$1"
  fi
}

# Guard against removing arbitrary folders/files, only remove folders that have at least a half-baked node configuration.
safer_rm() {
  if [ $# -eq 1 ]; then
    if a_in_b "$1" "$ALL_NODES"; then
      if get_auto_maintain_config "$1"; then
        HOME_DIR="$(get_home_dir "$1")"
        if [ -d "$HOME_DIR" ]; then
          if [ -d "$HOME_DIR/config" ]; then
            if [ -f "$HOME_DIR/config/config.toml" ]; then
              if [ -d "$HOME_DIR/data" ]; then
                info "Executing \"rm -r $HOME_DIR\"..."
                rm -r "$HOME_DIR"
              else
                warn "Anxious to run \"rm -r ${HOME_DIR}\" automatically, folder does not contain data folder, skipping..."
              fi
            else
              warn "Anxious to run \"rm -r ${HOME_DIR}\" automatically, folder does not contain config file, skipping..."
            fi
          else
            warn "Anxious to run \"rm -r ${HOME_DIR}\" automatically, folder does not contain config folder, skipping..."
          fi
        else
          warn "Anxious to run \"rm -r ${HOME_DIR}\" automatically, folder does not exist, skipping..."
        fi
      else
        warn "Node \"${1}\" has auto_maintain_config set to false, skipping..."
      fi
    else
      warn "Anxious to delete \"${1}\" automatically, node not in configuration, skipping..."
    fi
  else
    warn "Anxious to delete \"${*}\" automatically, looks like multiple paths, skipping..."
  fi
}

exec_function() {
  NODE="$1"
  shift
  GAIAD_BINARY="$(get_gaiad_binary "$NODE")"
  HOME_DIR="$(get_home_dir "$NODE")"
  RPC_PORT="http://localhost:$(get_rpc_port "$NODE")"
  CHAIN_ID="$(get_chain_id "$NODE")"
  # Possibly the below identification of commands is overkill, since the client.toml configuration works again.
  # But there were times it didn't work so we keep it for compatibility.
  if [ $# -eq 0 ]; then
    "$GAIAD_BINARY"
    echo "--home ${HOME_DIR}"
    echo "--node ${RPC_PORT}"
    echo "--chain-id ${CHAIN_ID}"
    echo "--keyring-backend test"
  else
    case "$1" in
      "collect-gentxs" | "config" | "debug" | "export" | "help" | "rollback" | "start" | "tendermint" | "testnet" | "validate-genesis" | "version")
        "${GAIAD_BINARY}" --home "${HOME_DIR}" "$@"
        ;;
      "keys" )
        "${GAIAD_BINARY}" --home "${HOME_DIR}" --keyring-backend test "$@"
        ;;
      "add-genesis-account" | "gentx" )
        "${GAIAD_BINARY}" --home "${HOME_DIR}" --keyring-backend test --node "${RPC_PORT}" "$@"
        ;;
      "tx" )
        "${GAIAD_BINARY}" --home "${HOME_DIR}" --keyring-backend test --node "${RPC_PORT}" --chain-id "${CHAIN_ID}" "$@"
        ;;
      "status" )
        "${GAIAD_BINARY}" --home "${HOME_DIR}" --node "${RPC_PORT}" "$@"
        ;;
      "query" | "q" )
        "${GAIAD_BINARY}" --home "${HOME_DIR}" --node "${RPC_PORT}" --chain-id "${CHAIN_ID}" "$@"
        ;;
      "init" )
        "${GAIAD_BINARY}" --home "${HOME_DIR}" --chain-id "${CHAIN_ID}" "$@"
        ;;
      *)
        "${GAIAD_BINARY}" --home "${HOME_DIR}" "$@"
    esac
  fi
}

# fund_wallet <node_name> <wallet_name>
fund_wallet() {
  NODE="${1}"
  WALLET_NAME="${2}"
  GAIAD_BINARY="$(get_gaiad_binary "$NODE")"
  HOME_DIR="$(get_home_dir "$NODE")"
  RPC="http://localhost:$(get_rpc_port "$NODE")"
  CHAIN_ID="$(get_chain_id "$NODE")"
  DENOM="$(get_staking_denom "$NODE")"
  NETWORK="$(get_network "$NODE")"
  NETWORK_HOME_DIR="$(get_home_dir "$NETWORK")"
  WALLET_ADDRESS="$("${GAIAD_BINARY}" keys show \
    "${WALLET_NAME}" \
    --keyring-backend test \
    --keyring-dir "${NETWORK_HOME_DIR}" \
    --home "${HOME_DIR}" \
    --address)"
  if "${GAIAD_BINARY}" tx bank send \
      "wallet" \
      "${WALLET_ADDRESS}" \
      "1001000${DENOM}" \
      --fees "10${DENOM}" \
      --keyring-backend test \
      --keyring-dir "${NETWORK_HOME_DIR}" \
      --node "${RPC}" \
      --chain-id "${CHAIN_ID}" \
      --home "${HOME_DIR}" \
      --yes 1> /dev/null 2> /dev/null; then
    info "sent funding transaction for wallet '${WALLET_NAME}'"
  else
    exit_with_error "could not fund wallet '${WALLET_NAME}'. Please fund it manually"
  fi
}

# create_validator <node_name> <wallet>
create_validator() {
  NODE="${1}"
  WALLET="${2}"
  if a_in_b "${NODE}" "${VALIDATORS}"; then
    exit_with_error "validator already exists"
  fi
  GAIAD_BINARY="$(get_gaiad_binary "$NODE")"
  HOME_DIR="$(get_home_dir "$NODE")"
  RPC="http://localhost:$(get_rpc_port "$NODE")"
  CHAIN_ID="$(get_chain_id "$NODE")"
  NETWORK="$(get_network "$NODE")"
  NETWORK_HOME_DIR="$(get_home_dir "$NETWORK")"
  DENOM="$(get_staking_denom "$NODE")"
  CONSENSUS_KEY="$(get_consensus_key "$NODE")"
  "${GAIAD_BINARY}" tx staking create-validator \
  --amount=1000000"${DENOM}" \
  --chain-id "${CHAIN_ID}" \
  --pubkey="${CONSENSUS_KEY}" \
  --commission-max-change-rate=0.5 \
  --commission-rate=0.05 \
  --commission-max-rate=1 \
  --min-self-delegation=1000 \
  --home "${HOME_DIR}" \
  --keyring-backend test \
  --keyring-dir "${NETWORK_HOME_DIR}" \
  --from "${WALLET}" \
  --node "${RPC}" \
  --yes \
  --output json | sed 's/.*txhash": *"\([0-9A-F]*\)".*/Create-validator transaction hash: \1/'
}

# create_wallet <node_name> <wallet_name> [<wallet_name>...]
create_wallet() {
  NODE="$1"
  if ! a_in_b "$NODE" "$ALL_NODES"; then
    exit_with_error "node ${NODE} not found in configuration"
  fi
  shift
  GAIAD_BINARY="$(get_gaiad_binary "$NODE")"
  NETWORK="$(get_network "$NODE")"
  NETWORK_HOME_DIR="$(get_home_dir "$NETWORK")"
  HDPATH="$(get_hdpath "$NODE")"
  FUNDING_IN_PROGRESS=0
  while [ $# -gt 0 ];
  do
    # Check if the key is already imported.
    if "${GAIAD_BINARY}" keys show "$1" --keyring-backend test --home "${NETWORK_HOME_DIR}" --output json 1>/dev/null 2>/dev/null; then
      warn "key '${1}' already imported on network '${NETWORK}', skipping..."
      shift
      continue
    fi
    # If we have an invalid key on file, we will delete it so we can create a new.
    if [ -f "${NETWORK_HOME_DIR}/${1}_seed.json" ]; then
      KEY_MNEMONIC="$(stoml "${NETWORK_HOME_DIR}/${1}_seed.json" mnemonic)"
      if [ -z "${KEY_MNEMONIC}" ]; then
        warn "mnemonic not found for key '${1}' on network '${NETWORK}', creating new key..."
        rm "${NETWORK_HOME_DIR}/${1}_seed.json"
      fi
    fi
    # If the key file already exists, we will import the key.
    if [ -f "${NETWORK_HOME_DIR}/${1}_seed.json" ]; then
      KEY_MNEMONIC="$(stoml "${NETWORK_HOME_DIR}/${1}_seed.json" mnemonic)"
      if [ -z "${KEY_MNEMONIC}" ]; then
        warn "mnemonic could not be created for key '${1}' on network '${NETWORK}', skipping..."
        shift
        continue
      fi
      if [ -z "${HDPATH}" ]; then
        if ! echo "${KEY_MNEMONIC}" | "${GAIAD_BINARY}" keys add "$1" --recover --keyring-backend test --home "${NETWORK_HOME_DIR}" --output json 2>&1 1>/dev/null; then
          warn "could not add key '${1}' with mnemonic to network '${NETWORK}'"
          shift
          continue
        else
          info "key '${1}' with mnemonic added on network '${NETWORK}'"
        fi
      else
        if ! echo "${KEY_MNEMONIC}" | "${GAIAD_BINARY}" keys add "$1" --hd-path "$HDPATH" --recover --keyring-backend test --home "${NETWORK_HOME_DIR}" --output json 2>&1 1>/dev/null; then
          warn "could not add key '${1}' with mnemonic to network '${NETWORK}'"
          shift
          continue
        else
          info "key '${1}' with mnemonic added on network '${NETWORK}'"
        fi
      fi
    # If the key file does not exist, we will create a new key.
    else
      if [ -z "${HDPATH}" ]; then
        if ! "${GAIAD_BINARY}" keys add "$1" --keyring-backend test --home "${NETWORK_HOME_DIR}" --output json 1> "${NETWORK_HOME_DIR}/${1}_seed.json" 2>&1 1>/dev/null; then
          warn "could not create key '${1}' on network '${NETWORK}'"
          shift
          continue
        else
          info "created key '${1}' on network '${NETWORK}'"
        fi
      else
        if ! "${GAIAD_BINARY}" keys add "$1" --hd-path "$HDPATH" --keyring-backend test --home "${NETWORK_HOME_DIR}" --output json 1> "${NETWORK_HOME_DIR}/${1}_seed.json" 2>&1 1>/dev/null; then
          warn "could not create key '${1}' on network '${NETWORK}'"
          shift
          continue
        else
          info "created key '${1}' on network '${NETWORK}'"
        fi
      fi
    fi
    # We created a new key successfully. Let's fund it.
    if [ ${FUNDING_IN_PROGRESS} -ne 0 ]; then
      info "waiting for previous transaction to complete"
      sleep 7
    fi
    fund_wallet "${NODE}" "${1}"
    FUNDING_IN_PROGRESS=1
    shift
  done
}

explorer_requirements() {
  if [ -z "$(which yarn || echo)" ]; then
    exit_with_error "missing yarn, install instructions are at https://classic.yarnpkg.com/lang/en/docs/install"
  fi
  UNZIP="$(which unzip || echo)"
  if [ -z "$UNZIP" ]; then
    TAR="$(which tar || echo)"
    if [ -z "$TAR" ]; then
      exit_with_error "missing unzip AND tar, please install at least one"
    fi
  fi
}

explorer_download() {
  # Define parameters
  URL_ZIP="https://github.com/ping-pub/explorer/archive/refs/tags/v0.45.x.zip"
  URL_TGZ="https://github.com/ping-pub/explorer/archive/refs/tags/v0.45.x.tar.gz"
  UNZIP="$(which unzip || echo)"
  TAR="$(which tar || echo)"
  DOWNLOAD_URL="${URL_ZIP}"
  BINARY="${HOME}/.gm/v0.45.x.zip"
  if [ -z "$UNZIP" ]; then
    DOWNLOAD_URL="${URL_TGZ}"
    BINARY="${HOME}/.gm/v0.45.x.tar.gz"
    if [ -z "$TAR" ]; then
      exit_with_error "missing unzip AND tar, please install at least one"
    fi
  fi
  # Download compressed source code
  DOWNLOADER="$(which wget)"
  if [ -n "${DOWNLOADER}" ]; then
    debug "downloading explorer using wget..."
    # shellcheck disable=SC2086
    "${DOWNLOADER}" -q -nd ${WGET_DOWNLOAD_OPTIONS:-} "${DOWNLOAD_URL}" -O "${BINARY}" || exit_with_error wget "${DOWNLOAD_URL}" failed
  else
    DOWNLOADER="$(which curl)"
    if [ -n "${DOWNLOADER}" ]; then
      debug "downloading ${DOWNLOAD_URL} using curl..."
      # shellcheck disable=SC2086
      "${DOWNLOADER}" -s -f -L ${CURL_DOWNLOAD_OPTIONS:-} "${DOWNLOAD_URL}" -o "${BINARY}" || exit_with_error curl "${DOWNLOAD_URL}" failed
    else
      exit_with_error "found URL ${DOWNLOAD_URL} but no downloader wget or curl"
    fi
  fi
  # Uncompress source code to target folder
  if [ -n "$UNZIP" ]; then
    "$UNZIP" "${BINARY}" -d "${HOME}/.gm" > /dev/null
    mv "${HOME}/.gm/explorer-0.45.x" "${HOME}/.gm/explorer"
  else
    "$TAR" -xzf "${BINARY}" -C "${HOME}/.gm"
    mv "${HOME}/.gm/explorer-0.45.x" "${HOME}/.gm/explorer"
  fi
}

explorer_init() {
  if [ -d "${HOME}/.gm/explorer" ] || [ -f "${HOME}/.gm/explorer" ]; then
    rm -rf "${HOME}/.gm/explorer"
  fi
  #git clone -b v0.45.x https://github.com/ping-pub/explorer "$HOME/.gm/explorer"
  explorer_download
}

explorer_config() {
  if ! [ -d "${HOME}/.gm/explorer" ]; then
    explorer_init
  fi
  rm -rf "${HOME}/.gm/explorer/src/chains"
  mkdir -p "${HOME}/.gm/explorer/src/chains/mainnet" "${HOME}/.gm/explorer/src/chains/testnet"
  # Todo: take all nodes into account
  for NODE in ${VALIDATORS};
  do
    CHAIN_ID="$(get_chain_id "$NODE")"
    APP="\"http://localhost:$(get_app_port "$NODE")\""
    RPC="\"http://localhost:$(get_rpc_port "$NODE")\""
    for SUBNODE in ${ALL_NODES};
    do
      SUB_CHAIN_ID="$(get_chain_id "$SUBNODE")"
      if [ "$NODE" == "$SUBNODE" ]; then
        continue
      fi
      if [ "$CHAIN_ID" == "$SUB_CHAIN_ID" ]; then
        SUBAPP="\"http://localhost:$(get_app_port "$SUBNODE")\""
        SUBRPC="\"http://localhost:$(get_rpc_port "$SUBNODE")\""
        APP="${APP},${SUBAPP}"
        RPC="${RPC},${SUBRPC}"
      fi
    done
    info "adding network '$NODE'"
    DENOM="$(get_staking_denom "$NODE")"
    DENOM_SYMBOL="$(echo "${DENOM}" | tr a-z A-Z)"
    PREFIX="$(get_wallet_account_prefix "$NODE")"
    GAIAD_BINARY="$(get_gaiad_binary "$NODE")"
    ("${GAIAD_BINARY}" version --long --output json 2>&1 || echo '{"cosmos_sdk_version":"v0.45.1"}') > "${HOME}/.gm/explorer/sdk_version.json"
    SDK_VERSION="$(stoml "${HOME}/.gm/explorer/sdk_version.json" cosmos_sdk_version | tr -d v)"
    cat > "${HOME}/.gm/explorer/src/chains/mainnet/${NODE}.json" << EOF
{
    "chain_name": "${CHAIN_ID}",
    "api": [${APP}],
    "rpc": [${RPC}],
    "sdk_version": "${SDK_VERSION}",
    "coin_type": "118",
    "min_tx_fee": "10",
    "addr_prefix": "${PREFIX}",
    "logo": "/logos/cosmos.svg",
    "assets": [{
        "base": "${DENOM}",
        "symbol": "${DENOM_SYMBOL}",
        "exponent": "0",
        "coingecko_id": "",
        "logo": "/logos/cosmos.svg"
    }]
}
EOF
  done
}

explorer_start() {
  # Copy of start() with a different actual start command and no genesis validation.
  if is_running "explorer"; then
    warn "explorer is already running, skipping"
  else
    HOME_DIR="$(get_home_dir "explorer")"
    GAIAD_BINARY="$(which yarn)"
    GAIAD_LOG="${HOME_DIR}/log"
    cd "${HOME_DIR}" && "$GAIAD_BINARY" --ignore-engines && nohup "$GAIAD_BINARY" serve > "$GAIAD_LOG" 2>&1 &
    GAIAD_PID=$!
    echo "$GAIAD_PID" > "$HOME_DIR/pid"
    info "explorer started, PID: $GAIAD_PID, LOG: $GAIAD_LOG"
    sleep 1
    if ! is_running "explorer"; then
      warn "explorer failed. Check the logs with \`gm log explorer\`."
    else
      info "explorer startup can take up to 20 seconds."
      info "check the status and the HTTP port in the log using \"gm log explorer\"."
    fi
  fi
}

explorer_status() {
  # Todo: nicer status page
  if is_running "explorer"; then
    HOME_DIR="$(get_home_dir "explorer")"
    GAIAD_PID_FILE="${HOME_DIR}/pid"
    GAIAD_PID="unknown"
    if [ -f "$GAIAD_PID_FILE" ]; then
      GAIAD_PID="$(cat "$GAIAD_PID_FILE")"
    fi
    info "explorer is running with PID ${GAIAD_PID}"
  else
    info "explorer is not running"
  fi
}

explorer_stop() {
  stop explorer
}
